%-----------------------------------------------------------------
\levelstay{Functions}
\label{sec:Functions}

In mathematics literature, \textit{function} is usually defined as
a special kind of \textit{relation} --- essentially a set of
ordered pairs with certain properties.

This approach is useful for some purposes, but here we will be
more interested in ``computable'' functions, at least in the sense
that a function is a ``machine'' that takes an element of one set
as input and returns an element of another, with the constraint
that a given input always returns the same output.

Because we need the notion of ``relation'' anyway, I'm going to
provide both definitions.

%-----------------------------------------------------------------
\leveldown{Relations}

A \textit{relation}, 
$\aSet{R}$, on $\aSet{S}_0, \aSet{S}_1, \ldots \aSet{S}_{n-1}$,  
is any subset 
$\aSet{R} \subseteq \aSet{S}_0 \times \aSet{S}_1 \times \ldots 
\times \aSet{S}_{n-1}$,
that is, a set of tuples.

Ambiguity note: a given set of tuples, $\aSet{R}$, can be
considered as a relation over many cartesian product sets.
The minimal such set is 
$\aSet{R}_0 \times \aSet{R}_1 \times \ldots \times
\aSet{R}_{n-1}$, 
where 
$\aSet{R}_i = \{ x | \exists r 
\in \aSet{R} \text{ s.t. } r_i = x\}$.

A general \textit{binary relation} is a set of ordered
pairs $\aSet{R} \subseteq \aSet{S}_0 \times \aSet{S}_1$.
It's common to write a binary relation as a predicate, 
$r(s_0,s_1) = ([s_0 \, s_1] \in \aSet{R})$,
or $(r \, s_0 \, s_1)$ in pseudo-code,
or as a binary operation $s_0 \, R \, s_1$.

An important special case
are binary relations on $\aSet{S}^2 = \aSet{S} \times \aSet{S}$
(often just written as ``binary relation on $\aSet{S}$''). 
In this case we can define certain properties:

\begin{description}
\item[Transitive]
$r(s_0,s_1) \text{ and } r(s_1,s_2) \Rightarrow r(s_0,s_2)$.
\item[Reflexive] $r(s,s)$ is always true.
\item[Symmetric] For $s_0 \neq s1$, $r(s_0,s_1)$ implies
$r(s_1,s_0)$.
\item[Antisymmetric] For $s_0 \neq s1$, $r(s_0,s_1)$ implies not
$r(s_1,s_0)$.
\end{description}
These properties determine 2 important classes of relations:
\begin{description}
\item[Equivalence] Transitive, reflexive, and symmetric.
\item[Partial order] Transitive, reflexive, and antisymmetric.
\end{description}

%-----------------------------------------------------------------
\levelstay{Functions}

A \textit{functional} binary relation, $\aSet{F}$ on $\aSet{X}
\times \aSet{Y}$ has exactly one $y \in \aSet{Y}$ for each
$x \in \aSet{X}$ such that $[x \, y] \in \aSet{F}$.
More conventional notation writes the \textit{function}, 
$f : \aSet{X} \rightarrow \aSet{Y}$ as $y = f(x)$.

Any function, $f : \aSet{X} \rightarrow \aSet{Y}$ defines an
equivalence relation on $\aSet{X}$ via 
$\aSet{E}_f = {[x_0 \, x_1] | f(x_0) = f(x_1)}$

%-----------------------------------------------------------------
\levelstay{Equivalence classes and quotient sets}

If $\aSet{E}$ is an equivalence relation on $\aSet{S}^2$, then we
can define the \textit{equivalence class} of $s_0$, $E(s_0) = \{
s_1 \in \aSet{S} | [s_0 \, s_1] \in \aSet{E} \}$.
The set of distinct equivalence classes partitions $\aSet{S}$,
and is called the \textit{quotient set}: $\aSet{S} / \aSet{E}$.

In the case where the equivalence relation is derived from a
function, we write $\aSet{S} / f$.

Equivalence classes and quotient sets will turn out to be
important. A common representational/implementation trick is to
use a larger but simpler (in some sense) space for calculations
which are meant to apply to a quotient space that actually has the
properties of interest. Homogeneous coordinates for affine and
projective spaces  are an important example.
The first one we will encounter here will be the rational numbers,
which are represented/implemented as pairs of integers
$[\text{numerator} \, \text{denominator}]$, but the actual
rational numbers are the equivalence classes defined by 
$\{ [[p_0 \, q_0] \, [p_1 \, q_1]] | p_0*q_1 = p_1*q_0 \}$,
that is, $[1 \, 2]$ and $[2 \, 4]$ represent the same rational.

%-----------------------------------------------------------------
%\levelstay{Computable functions}

%-----------------------------------------------------------------
%\levelstay{implementation}

%-----------------------------------------------------------------
%\levelstay{examples}

